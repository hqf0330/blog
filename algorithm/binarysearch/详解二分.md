---
title: 详解二分
categories:
  - 算法
tags:
  - 二分查找
halo:
  site: http://156.224.24.61:8090
  name: 27a7d5d3-550f-4128-8cb2-527db099174f
  publish: true
---
## 1. 什么是二分查找法

二分查找法，也称为折半查找算法（Binary Search），是一种在有序数组中高效查找指定元素的算法。它的基本思想是通过不断将查找区间减半来逐步逼近目标值，直到找到或者确定目标值不存在于数组中

`有序数组`: 二分查找的前提是数组必须是有序的，通常是升序或降序

### 1.1 算法步骤

1. **初始化指针**: 设定两个指针，`left`和`right`，分别指向数组的起始位置（0）和结束位置（数组长度减1）

2. **计算中间索引**: 计算中间位置的索引 `mid = (left + right) // 2` 或者使用无溢出的计算方式 `mid = left + ((right - left) >> 1)`

3. **比较**: 将中间位置数据和目标数据进行比较

    * 如果中间元素正好等于目标值，查找成功，返回该索引

    * 如果中间元素小于目标值，则目标值必定位于中间元素右侧的子数组中，因此更新查找区间为`left = mid + 1`

    * 如果中间元素大于目标值，则目标值必定位于中间元素左侧的子数组中，因此更新查找区间为`right = mid - 1`

4. **重复2和3**: 直到`left > right`，此时说明目标值不在数组中，查找失败

### 1.2 复杂度分析

* **时间复杂度**: 二分查找的时间复杂度为 O(log n)，其中 n 是数组中的元素数量。这是因为每次迭代都将查找范围缩小一半

* **空间复杂度**: 二分查找的空间复杂度为 O(1)，因为它只需要常数级别的额外空间

### 1.3 代码实现

```python
def exist(arr: List[int], num: int) -> bool:
    if not arr:
        return False
    left, right, mid = 0, len(arr) - 1, 0
    while left <= right:
        mid = (left + right) >> 1
        if arr[mid] == num:
            return True
        elif arr[mid] > num:
            right = mid - 1
        else:
            left = mid + 1
    return False
```

## 2. 边界问题

### 2.1 找到>=num的最左位置

当你需要在有序数组中找到第一个大于或等于给定值的元素时，这称为寻找左边界。在二分搜索的过程中，当你找到一个满足条件的元素时`nums[mid] >= target`，你不会立即返回，而是会继续在左半部分`left = mid + 1` 搜索，以确保找到的是最左边的位置。最终，当搜索区间收缩至`left == right`时，`left`指向的位置就是所求

**具体代码实现如下**:

```python
class Solution:
    @staticmethod
    def findLeft(arr: List[int], num: int) -> int:
        l, r, m = 0, len(arr) - 1, 0
        ans = -1
        while l <= r:
            m = l + ((r - l) >> 1)
            if arr[m] >= num:
                ans = m
                r = m - 1
            else:
                l = m + 1
        return ans
```

### 2.2 找到<=num的最右位置

相反，如果你需要找到最后一个小于或等于给定值的元素，这就是寻找右边界。在发现`nums[mid] <= target`时，你不会停止，而是会调整右边界往左探索`right = mid - 1`，以期找到最右边的满足条件的元素。同样地，当`left`和`right`靠近时，最终的`right`（或在某些实现中可能是`right + 1`，具体取决于边界处理）即为目标位置

**具体代码实现如下**:

```python
class Solution:
    @staticmethod
    def findRight(arr: List[int], num: int) -> int:
        l, r, m = 0, len(arr) - 1, 0
        ans = -1
        while l <= r:
            m = l + ((r - l) >> 1)
            if arr[m] <= num:
                ans = m
                l = m + 1
            else:
                r = m - 1
        return ans
```
